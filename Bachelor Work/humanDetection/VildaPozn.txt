using python 3.8
using tensorflow 2.4.0
using VPython

cd "..\..\Users\root\Documents\yolov4-deepsort-master vojta\yolov4-deepsort-master"
cd "..\..\Users\root\Documents\GitHub\Bachelor-thesis\Bachelor Work\humanDetection"


run tiny with webcam:
python object_tracker_modified.py --weights ./checkpoints/yolov4-tiny-416 --video 0 --output ./outputs/tiny_webcam.avi --model yolov4 --tiny

run non-tiny with webcam:
python object_tracker_modified.py --video 0 --output ./outputs/demo_webcam.avi --model yolov4

tiny with video:
python object_tracker_modified.py --weights ./checkpoints/yolov4-tiny-416 --video ./data/video/test.mp4 --output ./outputs/tiny_v2.avi --model yolov4 --tiny


//---------------------------
name: yolov4-gpu

dependencies:
  - python==3.8
  - pip
  - matplotlib
  - opencv
  - cudnn
  - cudatoolkit==10.1.243
  - pip:
    - tensorflow-gpu==2.4.0
    - opencv-python==4.1.2.30
    - lxml
    - tqdm
    - absl-py
    - easydict
    - pillow
//---------------------------


Raspberry pi with Python 3.9.2 and OpenCV 4.5.5. and np 1.22.2:

//------------ zdroje
https://ieeexplore.ieee.org/abstract/document/8633009 YOLO
https://ieeexplore.ieee.org/abstract/document/9204956 YOLO
https://ieeexplore.ieee.org/abstract/document/1565316 BLOB



//-----------------






#!/usr/bin/env python

from __future__ import division
from picamera.array import PiRGBArray
from picamera import PiCamera
import time
import cv2
import numpy as np
import socket
import struct
import math


class FrameSegment(object):
    """ 
    Object to break down image frame segment
    if the size of image exceed maximum datagram size 
    """
    MAX_DGRAM = 2**16
    MAX_IMAGE_DGRAM = MAX_DGRAM - 64 # extract 64 bytes in case UDP frame overflown
    
    def __init__(self, sock, port, addr="192.168.23.154"): #PCIPWiFi: 192.168.0.108, PCIPEth1: 169.254.64.229 Ubuntu IP: 192.168.0.74 Ubuntu Ether: 169.254.248.229
        self.s = sock
        self.port = port
        self.addr = addr

    def udp_frame(self, img):
        """ 
        Compress image and Break down
        into data segments 
        """
        compress_img = cv2.imencode('.jpg', img)[1]
        dat = compress_img.tobytes()
        size = len(dat)
        count = math.ceil(size/(self.MAX_IMAGE_DGRAM))
        array_pos_start = 0
        while count:
            array_pos_end = min(size, array_pos_start + self.MAX_IMAGE_DGRAM)
            self.s.sendto(struct.pack("B", count) +
                dat[array_pos_start:array_pos_end], 
                (self.addr, self.port)
                )
            array_pos_start = array_pos_end
            count -= 1



def main():
    """ Top level main function """
    '''
    camera = PiCamera()
    camera.resolution = (640, 480)
    camera.framerate = 60
    rawCapture = PiRGBArray(camera, size=(640, 480))
    time.sleep(0.1)
        
        '''
    # Set up UDP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    port = 5001

    fs = FrameSegment(s, port)

    cap = cv2.VideoCapture(1)
    '''
    for frame in camera.capture_continuous(rawCapture, format="bgr", use_video_port=True):
        image = frame.array
        fs.udp_frame(image)
        rawCapture.truncate(0)
    '''
    #time.sleep(0.1)
    while (cap.isOpened()):
        ret, frame = cap.read()
        fs.udp_frame(frame)

    
    cap.release()
    cv2.destroyAllWindows()
    s.close()

if __name__ == "__main__":
    main()
